---
title: 漫谈设计模式 1 - 观察者模式
date: 2020-10-10 18:33:00
tags: [code design, 设计模式]
description: 常见设计模式的介绍与剖析。深入原理，不能错过的经典设计模式之观察者模式（监听模式）。
---

# 观察者模式

## 介绍
观察者模式也称监听模式、发布/订阅模式、模型/视图模式、源/监听器模式、从属者模式等，是一种对象行为型模式。  

其原理是在对象间定义一种`一对多`的依赖关系，当这个对象状态发生改变时，所有依赖它的对象都会被通知并自动更新。  
核心是在被观察者与观察者之间建立一种自动触发的关系。  

## 模型 - python示例

```python
# 引入 ABCMeta 和 abstractmethod 来定义抽象类和抽象方法
from abc import ABCMeta, abstractmethod

class Observer(metaclass=ABCMeta):
    """`观察者`的基类"""
    @abstractmethod
    def update(self, observable, object):
        """各`观察者`各自实现此接口，等待被`被观察者`触发后执行相应动作"""
        pass

class Observable:
    """`被观察者`的基类"""
    def__ init__ (self):
        self._observers = []

    def addObserver(self, observer):
        """添加`观察者`"""
        self._observers.append(observer)

    def removeObserver(self, observer):
        """移除`观察者`"""
        self._observers.remove(observer)

    def notifyObservers(self, object=0):
        """`被观察者`在事件发生时调用此方法来通知所有`观察者`"""
        for o in self._observers:
            o.update(self, object)

# 分别实现`观察者`类实现Observer，`被观察者`类继承Observable
# `被观察者`实例调用基类的addObserver()方法来添加`观察者`实例
# 当`被观察者`实例运行时满足特定需求时，调用notifyObservers()方法触发激活所有`观察者`实例的update()方法

```

## 描述

### 推模型 拉模型

观察者模式可以根据侧重功能分为推模型和拉模型。

推模型指在事件触发时`被观察者`向`观察者`推送主题的详细信息，而拉模型则是只推送少量信息，由`观察者`自行决定是否需要拉取更多数据信息。

### 场景

1. 当多个对象的动作执行依赖于某个特定事件的发生   
2. 当一个对象的更新需要关联更新多个对象   

### 优缺点

**优点**

* 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系  
* 目标与观察者之间建立了一套触发机制  
* 支持广播通信  
* 符合“开闭原则”的要求  
> 在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。

**缺点**

* 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用  
* 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率  


<br/><br/><br/><br/><br/><br/><br/><br/>

```
【非原创声明】本文内容参考以下来源，此处仅做记录分享，如有侵权可联系删除 
  1. 《人人都懂设计模式：从生活中领悟设计模式（python实现）》  
  2. 菜鸟教程
  3. 维基百科
  4. 其他看完后忘了在哪但又确实很有用的的博客文章
```